package main;

import entities.Product;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

/**
 * @author cvoinea
 *
 * about the entityManager
 *   - persist -> puts a new entity instance in the context
 *   - flush -> instruct the implementation to persist the changes from the context
 *   - find -> retrieve an instance of an entity from the persistence layer by its id
 *   - getReference -> similar to fing, but gets the reference of a proxy of an entity; if the entity is not used afterwards, the select query is not triggered
 *   - contains -> allows to test if an instance of an entity it's in the context
 *   - remove -> detach the entity from the context and trigger the delete from the database
 *   - detach -> takes an entity out of the context without deleting it from the database
 *   - clear -> takes all the entities out of the context without deleting them from the database
 *   - merge -> similar to persist, but it adds a detached instance in the context (it already exists in the database, don't want to save it again)
 *   - refresh -> opposite of merge, will undo any change done in the context; it refreshes the value from the database
 */
public class Main {

    public static void main(String[] args) {

        EntityManagerFactory factory = Persistence.createEntityManagerFactory("persistence-unit-c11");
        EntityManager entityManager = factory.createEntityManager();
        try {
            entityManager.getTransaction().begin();

            Product p1 = new Product();
            p1.setId(17);
            p1.setName("prod " + p1.getId());
            entityManager.persist(p1); // the insert does not happen here;
             // however, when using auto-increment/GenerationType.IDENTITY strategy,
            // the persist might trigger the insert so that the context gets the id generated by the database

            entityManager.flush(); // the insert happens here
            System.out.println(":)");

            Product p2 = entityManager.find(Product.class, 13); //returns null if the id is not found
            System.out.println("find: " + p2.getName());

            // similar with find, but uses a proxy; if the entity is not used, the select is not triggered
            Product p3 = entityManager.getReference(Product.class, 13);
            System.out.println("getReference:" + p3.getName());

            System.out.println("contains id " + p3.getId() + ": " + entityManager.contains(p3)); // true

            Product p4 = entityManager.getReference(Product.class, 15);
            System.out.println("contains id " + p4.getId() + ": " + entityManager.contains(p4)); // true
            entityManager.remove(p4); // only works on context managed instances
            System.out.println("contains id " + p4.getId() + ": " + entityManager.contains(p4)); //false

            Product p5 = new Product();
            p5.setId(11);
            p5.setName("product " + p5.getId());
            entityManager.merge(p5); // adds in the context the detached instance; similar as persist, but the instance is not new, it already exists in DB
            System.out.println(entityManager.contains(p5)); // returns false because the instance was not in the context from the beginning, it was later merged



            entityManager.getTransaction().commit(); // normally the insert happens with the commit
        } catch (Exception e) {
            entityManager.getTransaction().rollback();
        } finally {
            entityManager.close();
        }
    }
}
